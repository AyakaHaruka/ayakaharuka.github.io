<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>低解密指数攻击</title>
    <link href="/Crypto/RSA/96c0de998cf4.html"/>
    <url>/Crypto/RSA/96c0de998cf4.html</url>
    
    <content type="html"><![CDATA[<p>RSA低解密指数攻击是指私钥持有者为了加快解密速度减少计算开销，生成密钥时选择较小的解密指数<span class="math inline"><em>d</em></span> ，然后用 <spanclass="math inline"><em>d</em></span> 和 <spanclass="math inline"><em>φ</em></span> 生成公钥 <spanclass="math inline"><em>e</em></span> 。这样生成的 <spanclass="math inline"><em>d</em></span> 较小， <spanclass="math inline"><em>e</em></span> 一般较大接近 <spanclass="math inline"><em>N</em></span> 。当解密指数 <spanclass="math inline"><em>d</em></span>满足一定条件时，可以通过一些数学方法来求解 <spanclass="math inline"><em>d</em></span>。 ## Wiener 攻击 攻击条件：<spanclass="math inline">$d&lt;\dfrac{1}{3}N^{\frac{1}{4}}$</span></p><p>根据 RSA 密钥生成算法 <span class="math display">$$ed=1+k\varphi\Longrightarrow\frac{d}{k}=\frac{1}{ek}+\frac{\varphi}{e}$$</span></p><p>由于 <span class="math inline"><em>e</em></span> 很大， <spanclass="math inline">$\dfrac{1}{ek}$</span> 可忽略不计，且 <spanclass="math inline"><em>φ</em> ≈ <em>N</em></span> ，所以 <spanclass="math display">$$\frac{d}{k}\approx\frac{N}{e}$$</span></p><p>Wiener 通过对 <span class="math inline">$\dfrac{N}{e}$</span>进行连分数展开，依次算出这个分数每一个渐进分数，得到 <spanclass="math inline">$\dfrac{d}{k}$</span> 的近似值，进而求得 <spanclass="math inline"><em>d</em></span> 。Wiener证明了这种攻击能精确地覆盖 <spanclass="math inline">$\dfrac{d}{k}$</span> 。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Sagemath</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wiener</span>(<span class="hljs-params">N, e</span>):<br>    cf = (e / N).continued_fraction().convergents()<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> cf:<br>        k, d = f.numer(), f.denom()<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, e*d, N) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> d, k<br></code></pre></td></tr></table></figure> ##Boneh-Durfee 攻击 论文原文：<ahref="https://eprint.iacr.org/2018/516.pdf">Partial Key Exposure Attackson RSA: Achieving the Boneh-Durfee Bound</a> ### 经典 Boneh-Durfee 攻击攻击条件：<spanclass="math inline"><em>d</em> ≤ <em>N</em><sup>0.292</sup></span></p><p>根据 RSA 密钥生成算法 <spanclass="math display"><em>e</em><em>d</em> = 1 + <em>ℓ</em><em>φ</em> = 1 + <em>ℓ</em> ⋅ (<em>N</em> − <em>p</em> − <em>q</em> + 1) ≡ 0 (mod  <em>e</em>)</span></p><p>设二元函数 <spanclass="math display"><em>f</em>(<em>x</em>, <em>y</em>) = 1 + <em>x</em> ⋅ (<em>N</em> + <em>y</em>)</span></p><p>其中 <spanclass="math inline"><em>x</em> = <em>ℓ</em>, <em>y</em> = −<em>p</em> − <em>q</em> + 1</span>，则 <spanclass="math inline"><em>f</em>(<em>x</em>, <em>y</em>) ≡ 0 (mod  <em>e</em>)</span>。如果在模 <span class="math inline"><em>e</em></span> 下解得该方程的根<span class="math inline"><em>x</em>, <em>y</em></span>，由 <spanclass="math inline"><em>e</em><em>d</em> = 1 + <em>x</em> ⋅ (<em>N</em> + <em>y</em>)</span>可以得到 <span class="math inline"><em>d</em></span>。</p><p>下面详细介绍如何求解 <spanclass="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span> 的根。</p><p>首先预估 <span class="math inline"><em>d</em></span> 的上界 <spanclass="math inline"><em>d</em> ≤ <em>N</em><sup><em>δ</em></sup></span>，其中 <span class="math inline"><em>δ</em> ≤ 0.292</span> ，则 <spanclass="math inline"><em>x</em>, <em>y</em></span> 的上界为 <spanclass="math inline">$X=N^\delta,Y=N^\frac{1}{2}$</span> 。 Boneh 和Durfee 使用了如下移位多项式：</p><p><span class="math display">$$\begin{cases}g^{BD.x}_{[u,i]}(x,y):=x^{u-i}f(x,y)^ie^{m-i}\\\\g^{BD.y}_{[u,j]}(x,y):=y^{j}f(x,y)^ue^{m-u}\end{cases}$$</span></p><p>它们的指标集为 <span class="math display">$$\begin{cases}\mathcal{I}_{BD,x}:=\{u=0,1,\cdots,m;i=0,1,\cdots,u\}\\\mathcal{I}_{BD,y1}:=\{u=0,1,\cdots,m;j=1,2,\cdots,k\}\end{cases}$$</span></p><p>其中 $ m,k $ 是可优化的参数，并且需满足 $ =k/m $ 。一般我们把 $ m,$视为可优化参数。 然后使用 <spanclass="math inline">(<em>x</em><em>X</em>, <em>y</em><em>Y</em>)</span>代入上述多项式，即计算 $ g^{BD.x}<em>{[u,i]}(xX,yY) $ 对于 $(u,i)</em>{BD,x} $ 和 $ g^{BD.y}_{[u,j]}(xX,yY) $ 对于 <spanclass="math inline">(<em>u</em>, <em>j</em>) ∈ ℐ<sub><em>B</em><em>D</em>, <em>y</em>1</sub></span>，取它们的系数向量作为行向量，构造弱 Boneh-Durfee 矩阵 <spanclass="math inline"><em>B</em></span> ，构造示例如下表（这里取 <spanclass="math inline"><em>m</em> = 2, <em>κ</em> = 1</span>）： <spanclass="math display">$$\begin{array}{c|}\hline&amp;1&amp;y&amp;y^2&amp;x&amp;xy&amp;xy^2&amp;xy^3&amp;x^2&amp;x^2y&amp;x^2y^2&amp;x^2y^3&amp;x^2y^4&amp;x^2y^5\\\hline g^{BD.x}_{[0,0]}&amp;e^2&amp;\\g^{BD.y}_{[0,1]}&amp;&amp;Ye^2\\g^{BD.y}_{[0,2]}&amp;&amp;&amp;Y^2e^2\\g^{BD.x}_{[1,0]}&amp;&amp;&amp;&amp;Xe^2\\g^{BD.x}_{[1,1]}&amp;-&amp;&amp;&amp;-&amp;XYe\\g^{BD.y}_{[1,1]}&amp;&amp;-&amp;&amp;&amp;-&amp;XY^2e\\g^{BD.y}_{[1,2]}&amp;&amp;&amp;-&amp;&amp;&amp;-&amp;XY^3e\\g^{BD.x}_{[2,0]}&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;X^2e^2\\g^{BD.x}_{[2,1]}&amp;&amp;&amp;&amp;-&amp;&amp;&amp;&amp;-&amp;X^2Ye\\g^{BD.x}_{[2,2]}&amp;-&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^2\\g^{BD.y}_{[2,1]}&amp;&amp;-&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^3\\g^{BD.y}_{[2,2]}&amp;&amp;&amp;-&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^4\\\hline\end{array}$$</span></p><p>从上表的构造示例可以看出， <spanclass="math inline"><em>B</em></span> 是一个三角矩阵。通过优化 <spanclass="math inline"><em>κ</em> = (1 − 2<em>δ</em>)/2</span>，该矩阵提供的弱 Boneh-Durfee 攻击可以使得当满足条件 <spanclass="math inline">$\delta\lt(7-2\sqrt{7})/6=0.284\cdots$</span>时攻击成功。 为了改良弱攻击， Boneh 和 Durfee开发了子格。更确切地说，他们使用了上述矩阵的子矩阵作为格基。因此他们替换掉了原本的指标集<spanclass="math inline">ℐ<sub><em>B</em><em>D</em>, <em>y</em>1</sub></span>，转而使用如下指标集：<spanclass="math display">ℐ<sub><em>B</em><em>D</em>, <em>y</em>2</sub> := {<em>u</em> = 0, 1, ⋯, <em>m</em>; <em>j</em> = 1, 2, ⋯, <em>k</em> + ⌊<em>τ</em><em>u</em>⌋}</span></p><p>其中 <span class="math inline"><em>τ</em></span> 是可优化参数且 $ 0 $。通过优化参数 <span class="math inline"><em>k</em> = 0</span> 和 <spanclass="math inline"><em>τ</em> = 1 − 2<em>δ</em></span> ，通过 $g^{BD.x}<em>{[u,i]}(xX,yY) $ 对于 $ (u,i)</em>{BD,x} $ 和 $g^{BD.y}<em>{[u,j]}(xX,yY) $ 对于 $ (u,j)</em>{BD,y1} $的系数向量作为行向量构造的矩阵 <spanclass="math inline"><em>B</em></span> 提供的强 Boneh-Durfee攻击可以使得当满足条件 $ (1-1/)=0.292$ 时攻击成功。但这么做矩阵 <spanclass="math inline"><em>B</em></span>可能不再是三角矩阵，所以需要进一步分析（ Herrmann-May 的优化矩阵）。 ###Herrmann-May 矩阵 Herrmann 和 May 引入了一个新变量，将强 Boneh-Durfee矩阵变换成了三角形：<spanclass="math display"><em>z</em> := 1 + <em>x</em><em>y</em></span></p><p>其上界为 <spanclass="math inline"><em>Z</em> := <em>X</em><em>Y</em> = <em>N</em><sup><em>δ</em> + 1/2</sup></span>。于是上述矩阵构造就变成了如下矩阵（<spanclass="math inline"><em>m</em> = 2, <em>κ</em> = 1/2, <em>τ</em> = 1</span>）：<span class="math display">$$\begin{array}{c|}\hline&amp;1&amp;y&amp;x&amp;z&amp;yz&amp;y^2z&amp;x^2&amp;xz&amp;z^2&amp;yz^2&amp;y^2z^2&amp;y^3z^2\\\hlineg^{BD.x}_{[0,0]}&amp;e^2&amp;\\g^{BD.y}_{[0,1]}&amp;&amp;Ye^2\\g^{BD.x}_{[1,0]}&amp;&amp;&amp;Xe^2\\g^{BD.x}_{[1,1]}&amp;&amp;&amp;-&amp;Ze\\g^{BD.y}_{[1,1]}&amp;-&amp;&amp;&amp;-&amp;YZe\\g^{BD.y}_{[1,2]}&amp;&amp;-&amp;&amp;&amp;-&amp;Y^2Ze\\g^{BD.x}_{[2,0]}&amp;&amp;&amp;&amp;&amp;&amp;&amp;X^2e^2\\g^{BD.x}_{[2,1]}&amp;&amp;&amp;&amp;&amp;&amp;&amp;-&amp;XZe\\g^{BD.x}_{[2,2]}&amp;&amp;&amp;&amp;&amp;&amp;&amp;-&amp;-&amp;Z^2\\g^{BD.y}_{[2,1]}&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;&amp;-&amp;-&amp;YZ^2\\g^{BD.y}_{[2,2]}&amp;-&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;&amp;-&amp;-&amp;Y^2Z^2\\g^{BD.y}_{[2,3]}&amp;&amp;-&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;&amp;-&amp;-&amp;Y^3Z^2\\\hline\end{array}$$</span></p><p>这样一来，所有单项式必然不会同时包含 <spanclass="math inline"><em>x</em></span> 和 <spanclass="math inline"><em>y</em></span> 。尽管线性化表达式 <spanclass="math inline"><em>z</em> = 1 + <em>x</em><em>y</em></span> 会丢失<span class="math inline"><em>x</em></span> 和 <spanclass="math inline"><em>y</em></span>的信息，但通过展开即可恢复这些信息。把矩阵变换成三角矩阵能让我们更轻松地分析它的结构。</p><p>经典 Boneh-Durfee 攻击工具：<ahref="https://github.com/mimoo/RSA-and-LLL-attacks">RSA-and-LLL-attacks</a></p><h2 id="已知部分-d-的-boneh-durfee-攻击">已知部分 d 的 Boneh-Durfee攻击</h2><p>先定义两个函数： <span class="math display">$$l^{MSBs}_{k,\tau}(x):=\max\{0,\left\lceil\frac{x-k}{\tau+1}\right\rceil\}\quad和\quadl^{LSBs}_{k,\tau}(x):=\max\{0,\left\lceil\frac{x-k}{\tau}\right\rceil\}$$</span> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lMSBs</span>(<span class="hljs-params">k,tau,x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,ceil((x-k)/(tau+<span class="hljs-number">1</span>)))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lLSBs</span>(<span class="hljs-params">k,tau,x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,ceil((x-k)/tau))<br></code></pre></td></tr></table></figure> ### 已知部分低位（LSB） 已知 d 部分低位意味着<spanclass="math inline"><em>d</em> = <em>d</em><sub>0</sub> + <em>d</em><sub>1</sub><em>M</em></span>，其中 <spanclass="math inline"><em>d</em><sub>0</sub> &gt; <em>N</em><sup><em>δ</em> − <em>ε</em></sup></span>且 <spanclass="math inline"><em>d</em><sub>1</sub> &lt; <em>N</em><sup><em>ε</em></sup></span>，<span class="math inline"><em>M</em></span> 是模数且 <spanclass="math inline"><em>M</em> &lt; 2<sup>⌊(<em>δ</em> − <em>ε</em>)log <em>N</em>⌋</sup></span>，已知 <span class="math inline">(<em>N</em>, <em>e</em>)</span> 和<span class="math inline"><em>d</em><sub>0</sub></span> 和 <spanclass="math inline"><em>M</em></span> 的情况下的 Boneh_Durfee 攻击。如下攻击方法可以当 <spanclass="math inline">$\varepsilon\lt\dfrac{1+\delta-\sqrt{-1+6\delta-3\delta^2}}{2},\delta\leqslant\dfrac{9-\sqrt{21}}{12}$</span>时攻击成功。 根据 RSA 密钥生成算法 <spanclass="math display"><em>e</em>(<em>d</em><sub>1</sub><em>M</em> + <em>d</em><sub>0</sub>) = 1 + <em>ℓ</em><em>φ</em> = 1 + <em>ℓ</em> ⋅ (<em>N</em> − <em>p</em> − <em>q</em> + 1)</span></p><p>上式对 <span class="math inline"><em>e</em><em>M</em></span>取模，得到一个模二元函数 <spanclass="math display"><em>f</em><sub><em>L</em><em>S</em><em>B</em><em>s</em></sub>(<em>x</em>, <em>y</em>) := 1 − <em>e</em><em>d</em><sub>0</sub> + <em>x</em> ⋅ (<em>N</em> + <em>y</em>) (mod  <em>e</em><em>M</em>)</span></p><p>它的根为 $ (x,y)=(,-p-q+1) $ ，上界为 $ xN<sup>{},yN</sup>{} $ 。回顾 Boneh-Durfee 的二元函数 <spanclass="math display"><em>f</em><sub><em>B</em><em>D</em></sub>(<em>x</em>, <em>y</em>) := 1 + <em>x</em> ⋅ (<em>N</em> + <em>y</em>) (mod  <em>e</em>)</span></p><p>由此对 Boneh-Durfee 的移位多项式 <spanclass="math inline"><em>g</em><sub>[<em>u</em>, <em>i</em>]</sub><sup><em>B</em><em>D</em>.<em>x</em></sup>(<em>x</em>, <em>y</em>), <em>g</em><sub>[<em>u</em>, <em>j</em>]</sub><sup><em>B</em><em>D</em>.<em>y</em></sup>(<em>x</em>, <em>y</em>)</span>进行改进，得到如下 LSB 移位多项式： <span class="math display">$$\begin{cases}g^{LSBs.x}_{[u,i]}(x,y):=x^{u-i}f_{LSBs}(x,y)^i(eM)^{m-i}\\\\g^{LSBs.y}_{[u,j]}(x,y):=y^{j}f_{LSBs}(x,y)^{u-l^{LSBs}_{k,\tau}(j)}f_{BD}(x,y)^{l^{LSBs}_{k,\tau}(j)}e^{m-u}M^{(m-(u-l^{LSBs}_{k,\tau}(j)))}\end{cases}$$</span></p><p>它们的指标集为 <spanclass="math display">$$\begin{cases}\mathcal{I}_{LSBs,x}:=\{u=0,1,\cdots,m;i=0,1,\cdots,u\}\\\mathcal{I}_{LSBs,y}:=\{u=0,1,\cdots,m;j=1,2,\cdots,k+\lfloor\tauu\rfloor\}\end{cases}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gLSBs_x</span>(<span class="hljs-params">u,i,fLSBs,fBD,X,Y,m,kappa,tau</span>):<br>    <span class="hljs-keyword">return</span> X^(u-i) * fLSBs(X,Y)^i * (e*M)^(m-i)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gLSBs_y</span>(<span class="hljs-params">u,j,fLSBs,fBD,X,Y,m,kappa,tau</span>):<br>    k = m * kappa<br>    l = lLSBs(k,tau,j)<br>    <span class="hljs-keyword">return</span> Y^j * fLSBs(X,Y)^(u-l) * fBD(X,Y)^l*e^(m-u) * M^(m-u+l)<br></code></pre></td></tr></table></figure><p>移位多项式在模 <spanclass="math inline">(<em>e</em><em>M</em>)<sup><em>m</em></sup></span>下与原方程有相同的根。于是构造矩阵 <spanclass="math inline"><em>B</em></span> （ $ m=2,/2, $ ）：</p><p><span class="math display">$$\begin{array}{c|}\hline&amp;1&amp;y&amp;x&amp;xy&amp;xy^2&amp;xy^3&amp;x^2&amp;x^2y&amp;x^2y^2&amp;x^2y^3&amp;x^2y^4&amp;x^2y^5\\\hlineg^{LSBs.x}_{[0,0]}&amp;(eM)^2&amp;\\g^{LSBs.y}_{[0,1]}&amp;&amp;Y(eM)^2\\g^{LSBs.x}_{[1,0]}&amp;&amp;&amp;X(eM)^2\\g^{LSBs.x}_{[1,1]}&amp;-&amp;&amp;-&amp;XYeM\\g^{LSBs.y}_{[1,1]}&amp;&amp;-&amp;&amp;-&amp;XY^2eM\\g^{LSBs.y}_{[1,2]}&amp;&amp;&amp;&amp;&amp;-&amp;XY^3eM^2\\g^{LSBs.x}_{[2,0]}&amp;&amp;&amp;&amp;&amp;&amp;&amp;X^2(eM)^2\\g^{LSBs.x}_{[2,1]}&amp;&amp;&amp;-&amp;&amp;&amp;&amp;-&amp;X^2YeM\\g^{LSBs.x}_{[2,2]}&amp;-&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^2\\g^{LSBs.y}_{[2,1]}&amp;&amp;-&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^3\\g^{LSBs.y}_{[2,2]}&amp;&amp;&amp;&amp;&amp;-&amp;-&amp;&amp;&amp;-&amp;-&amp;X^2Y^4M\\g^{LSBs.y}_{[2,3]}&amp;&amp;&amp;&amp;&amp;&amp;-&amp;&amp;&amp;&amp;-&amp;-&amp;X^2Y^5M^2\\\hline\end{array}$$</span></p><p>如下是魔改 <ahref="https://github.com/mimoo/RSA-and-LLL-attacks">RSA-and-LLL-attacks</a>代码的弱化版带 LSB 的 Boneh-Durfee攻击（弱化版是指由于我的代码并没有实现论文算法的全部细节，导致 <spanclass="math inline"><em>δ</em></span> 的上界会比论文中所说的 <spanclass="math inline">0.368</span> 小一点，大概在 <spanclass="math inline">0.33</span> 左右，<spanclass="math inline"><em>ε</em></span> 也是，约 <spanclass="math inline">0.17</span>），强化版代码可以根据论文完整思路自行实现。</p><p>Sagemath 代码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Sagemath</span><br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Config</span><br><span class="hljs-comment">##########################################</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting debug to true will display more informations</span><br><span class="hljs-string">about the lattice, the bounds, the vectors...</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>debug = <span class="hljs-literal">True</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Setting strict to true will stop the algorithm (and</span><br><span class="hljs-string">return (-1, -1)) if we don&#x27;t have a correct</span><br><span class="hljs-string">upperbound on the determinant. Note that this</span><br><span class="hljs-string">doesn&#x27;t necesseraly mean that no solutions</span><br><span class="hljs-string">will be found since the theoretical upperbound is</span><br><span class="hljs-string">usualy far away from actual results. That is why</span><br><span class="hljs-string">you should probably use `strict = False`</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>strict = <span class="hljs-literal">False</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is experimental, but has provided remarkable results</span><br><span class="hljs-string">so far. It tries to reduce the lattice as much as it can</span><br><span class="hljs-string">while keeping its efficiency. I see no reason not to use</span><br><span class="hljs-string">this option, but if things don&#x27;t work, you should try</span><br><span class="hljs-string">disabling it</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>helpful_only = <span class="hljs-literal">False</span><br>dimension_min = <span class="hljs-number">7</span> <span class="hljs-comment"># stop removing if lattice reaches that dimension</span><br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Functions</span><br><span class="hljs-comment">##########################################</span><br><br><span class="hljs-comment"># display stats on helpful vectors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">helpful_vectors</span>(<span class="hljs-params">BB, modulus</span>):<br>    nothelpful = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> BB[ii,ii] &gt;= modulus:<br>            nothelpful += <span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">print</span>(nothelpful, <span class="hljs-string">&quot;/&quot;</span>, BB.dimensions()[<span class="hljs-number">0</span>], <span class="hljs-string">&quot; vectors are not helpful&quot;</span>)<br><br><span class="hljs-comment"># display matrix picture with 0 and X</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_overview</span>(<span class="hljs-params">BB, bound</span>):<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        a = (<span class="hljs-string">&#x27;%02d &#x27;</span> % ii)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">1</span>]):<br>            a += <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">if</span> BB[ii,jj] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">60</span>:<br>                a += <span class="hljs-string">&#x27; &#x27;</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            a += <span class="hljs-string">&#x27;~&#x27;</span><br>        <span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-comment"># tries to remove unhelpful vectors</span><br><span class="hljs-comment"># we start at current = n-1 (last vector)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_unhelpful</span>(<span class="hljs-params">BB, monomials, bound, current</span>):<br>    <span class="hljs-comment"># end of our recursive function</span><br>    <span class="hljs-keyword">if</span> current == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt;= dimension_min:<br>        <span class="hljs-keyword">return</span> BB<br><br>    <span class="hljs-comment"># we start by checking from the end</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(current, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># if it is unhelpful:</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            affected_vectors = <span class="hljs-number">0</span><br>            affected_vector_index = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># let&#x27;s check if it affects other vectors</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ii + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                <span class="hljs-comment"># if another vector is affected:</span><br>                <span class="hljs-comment"># we increase the count</span><br>                <span class="hljs-keyword">if</span> BB[jj, ii] != <span class="hljs-number">0</span>:<br>                    affected_vectors += <span class="hljs-number">1</span><br>                    affected_vector_index = jj<br><br>            <span class="hljs-comment"># level:0</span><br>            <span class="hljs-comment"># if no other vectors end up affected</span><br>            <span class="hljs-comment"># we remove it</span><br>            <span class="hljs-keyword">if</span> affected_vectors == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* removing unhelpful vector&quot;</span>, ii)<br>                BB = BB.delete_columns([ii])<br>                BB = BB.delete_rows([ii])<br>                monomials.pop(ii)<br>                BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> BB<br><br>            <span class="hljs-comment"># level:1</span><br>            <span class="hljs-comment"># if just one was affected we check</span><br>            <span class="hljs-comment"># if it is affecting someone else</span><br>            <span class="hljs-keyword">elif</span> affected_vectors == <span class="hljs-number">1</span>:<br>                affected_deeper = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> kk <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(affected_vector_index + <span class="hljs-number">1</span>, BB.dimensions()[<span class="hljs-number">0</span>]):<br>                    <span class="hljs-comment"># if it is affecting even one vector</span><br>                    <span class="hljs-comment"># we give up on this one</span><br>                    <span class="hljs-keyword">if</span> BB[kk, affected_vector_index] != <span class="hljs-number">0</span>:<br>                        affected_deeper = <span class="hljs-literal">False</span><br>                <span class="hljs-comment"># remove both it if no other vector was affected and</span><br>                <span class="hljs-comment"># this helpful vector is not helpful enough</span><br>                <span class="hljs-comment"># compared to our unhelpful one</span><br>                <span class="hljs-keyword">if</span> affected_deeper <span class="hljs-keyword">and</span> <span class="hljs-built_in">abs</span>(bound - BB[affected_vector_index, affected_vector_index]) &lt; <span class="hljs-built_in">abs</span>(bound - BB[ii, ii]):<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* removing unhelpful vectors&quot;</span>, ii, <span class="hljs-string">&quot;and&quot;</span>, affected_vector_index)<br>                    BB = BB.delete_columns([affected_vector_index, ii])<br>                    BB = BB.delete_rows([affected_vector_index, ii])<br>                    monomials.pop(affected_vector_index)<br>                    monomials.pop(ii)<br>                    BB = remove_unhelpful(BB, monomials, bound, ii-<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> BB<br>    <span class="hljs-comment"># nothing happened</span><br>    <span class="hljs-keyword">return</span> BB<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lMSBs</span>(<span class="hljs-params">k,tau,x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,ceil((x-k)/(tau+<span class="hljs-number">1</span>)))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lLSBs</span>(<span class="hljs-params">k,tau,x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,ceil((x-k)/tau))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gLSBs_x</span>(<span class="hljs-params">u,i,fLSBs,fBD,X,Y,m,k</span>):<br>    <span class="hljs-keyword">return</span> X^(u-i) * fLSBs(X,Y)^i * (e*M)^(m-i)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gLSBs_y</span>(<span class="hljs-params">u,j,fLSBs,fBD,X,Y,m,k</span>):<br>    l = lLSBs(k,tau,j)<br>    <span class="hljs-keyword">return</span> Y^j * fLSBs(X,Y)^(u-l) * fBD(X,Y)^l*e^(m-u) * M^(m-u+l)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix_overview</span>(<span class="hljs-params">BB, bound</span>):<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">0</span>]):<br>        a = (<span class="hljs-string">&#x27;%02d &#x27;</span> % ii)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(BB.dimensions()[<span class="hljs-number">1</span>]):<br>            a += <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">if</span> BB[ii,jj] == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;X&#x27;</span><br>            <span class="hljs-keyword">if</span> BB.dimensions()[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">60</span>:<br>                a += <span class="hljs-string">&#x27; &#x27;</span><br>        <span class="hljs-keyword">if</span> BB[ii, ii] &gt;= bound:<br>            a += <span class="hljs-string">&#x27;~&#x27;</span><br>        <span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LSB_boneh_durfee</span>(<span class="hljs-params">N, e, d0, M, mm, kk, tau, XX, YY</span>):<br>    modulus = e * M<br>    P.&lt;x,y&gt; = ZZ[]<br>    fLSBs = <span class="hljs-number">1</span>-e*d0 + x * (N + y)<br>    fBD = <span class="hljs-number">1</span> + x * (N + y)<br>    <span class="hljs-comment"># 论文所描述的新的 LSB 移位多项式</span><br>    gg = []<br>    <span class="hljs-keyword">for</span> uu <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mm+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(uu+<span class="hljs-number">1</span>):<br>            gg.append(gLSBs_x(uu,ii,fLSBs,fBD,XX*x,YY*y,mm,kk))<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,kk+floor(tau*uu)+<span class="hljs-number">1</span>):<br>            gg.append(gLSBs_y(uu,jj,fLSBs,fBD,XX*x,YY*y,mm,kk))<br>    <span class="hljs-comment"># generate the monomials</span><br>    nn = <span class="hljs-built_in">len</span>(gg)<br>    monomials = []<br>    degx, degy = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>        monomials.append(x^degx*y^degy)<br>        degy += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> degy &gt;= (degx+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>:<br>            degx, degy = degx+<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 构造矩阵 B 用来 LLL</span><br>    BB = Matrix(ZZ, nn)<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>        g = gg[ii]<br>        BB[ii, <span class="hljs-number">0</span>] = g(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ii+<span class="hljs-number">1</span>):<br>            BB[ii, jj] = g.monomial_coefficient(monomials[jj])<br><br>    <span class="hljs-comment"># Prototype to reduce the lattice</span><br>    <span class="hljs-keyword">if</span> helpful_only:<br>        <span class="hljs-comment"># automatically remove</span><br>        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># reset dimension</span><br>        nn = BB.dimensions()[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> nn == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;failure&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># check if vectors are helpful</span><br>    <span class="hljs-keyword">if</span> debug:<br>        helpful_vectors(BB, modulus^mm)<br>    <br>    <span class="hljs-comment"># check if determinant is correctly bounded</span><br>    det = BB.det()<br>    bound = modulus^(mm*nn)<br>    <span class="hljs-keyword">if</span> det &gt;= bound:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;We do not have det &lt; bound. Solutions might not be found.&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Try with highers m and t.&quot;</span>)<br>        <span class="hljs-keyword">if</span> debug:<br>            diff = (log(det) - log(bound)) / log(<span class="hljs-number">2</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;size det(L) - size (e*M)^(m*n) = &quot;</span>, floor(diff))<br>        <span class="hljs-keyword">if</span> strict:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;det(L) &lt; (e*M)^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;</span>)<br><br>    <span class="hljs-comment"># display the lattice basis</span><br>    <span class="hljs-keyword">if</span> debug:<br>        matrix_overview(BB, modulus^mm)<br><br>    <span class="hljs-comment"># LLL</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;</span>)<br>    <br>    BB = BB.LLL()<br><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LLL is done!&quot;</span>)<br><br>    <span class="hljs-comment"># transform vector i &amp; j -&gt; polynomials 1 &amp; 2</span><br>    <span class="hljs-keyword">if</span> debug:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;looking for independent vectors in the lattice&quot;</span>)<br>    found_polynomials = <span class="hljs-literal">False</span><br>        <br>    <span class="hljs-keyword">for</span> pol1_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> pol2_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pol1_idx + <span class="hljs-number">1</span>, nn):<br>            <span class="hljs-comment"># for i and j, create the two polynomials</span><br>            PR.&lt;w,z&gt; = PolynomialRing(ZZ)<br>            pol1 = pol2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> jj <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nn):<br>                pol1 += monomials[jj](w,z) * BB[pol1_idx, jj] / monomials[jj](XX,YY)<br>                pol2 += monomials[jj](w,z) * BB[pol2_idx, jj] / monomials[jj](XX,YY)<br>    <br>            <span class="hljs-comment"># resultant</span><br>            PR.&lt;q&gt; = PolynomialRing(ZZ)<br>            rr = pol1.resultant(pol2)<br>    <br>            <span class="hljs-comment"># are these good polynomials?</span><br>            <span class="hljs-keyword">if</span> rr.is_zero() <span class="hljs-keyword">or</span> rr.monomials() == [<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;found them, using vectors&quot;</span>, pol1_idx, <span class="hljs-string">&quot;and&quot;</span>, pol2_idx)<br>                found_polynomials = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> found_polynomials:<br>            <span class="hljs-keyword">break</span><br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found_polynomials:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;no independant vectors could be found. This should very rarely happen...&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    rr = rr(q, q)<br>    <br>    <span class="hljs-comment"># solutions</span><br>    soly = rr.roots()<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(soly) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Your prediction (delta) is too small&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <br>    soly = soly[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    ss = pol1(q, soly)<br>    solx = ss.roots()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> solx, soly<br><br>debug = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>delta = <span class="hljs-number">0.33</span> <span class="hljs-comment"># this means that d &lt; N^delta</span><br>epsilon = <span class="hljs-number">0.17</span><br><br><span class="hljs-comment">############################################</span><br><span class="hljs-comment"># Example</span><br><span class="hljs-comment">##########################################</span><br><br>p, q = getPrime(<span class="hljs-number">1024</span>), getPrime(<span class="hljs-number">1024</span>)<br>N = p * q<br><br>d = getPrime(<span class="hljs-built_in">int</span>(<span class="hljs-number">2048</span>*delta)-<span class="hljs-number">1</span>)<br>phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>e = <span class="hljs-built_in">pow</span>(d, -<span class="hljs-number">1</span>, phi)<br><br>M = getPrime(<span class="hljs-built_in">int</span>(<span class="hljs-number">2048</span>*(delta-epsilon)))<br>d0 = d % M<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;N =&quot;</span>, N)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;e =&quot;</span>, e)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;M =&quot;</span>, M)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;d0 =&quot;</span>, d0)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;We want to find:&quot;</span>, d)<br><br>m = <span class="hljs-number">4</span> <span class="hljs-comment"># size of the lattice (bigger the better/slower)</span><br><br>k = <span class="hljs-number">1</span> <span class="hljs-comment"># optimization</span><br>tau = <span class="hljs-number">1</span> <span class="hljs-comment"># optimization</span><br>X = floor(N^delta)<br>Y = <span class="hljs-number">2</span>*floor(N^(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">if</span> debug:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== checking values ===&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* delta:&quot;</span>, delta)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* delta &lt; 0.368&quot;</span>, delta &lt; <span class="hljs-number">0.368</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* epsilon:&quot;</span>, epsilon)<br>    epsilon_bounds = (<span class="hljs-number">1</span> + delta - sqrt(-<span class="hljs-number">1</span> + <span class="hljs-number">6</span>*delta - <span class="hljs-number">3</span>*delta^<span class="hljs-number">2</span>)) / <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* epsilon &lt;&quot;</span>, epsilon_bounds, epsilon &lt; epsilon_bounds)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* size of e:&quot;</span>, <span class="hljs-built_in">int</span>(log(e)/log(<span class="hljs-number">2</span>)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* size of N:&quot;</span>, <span class="hljs-built_in">int</span>(log(N)/log(<span class="hljs-number">2</span>)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;* m:&quot;</span>, m)<br><br><span class="hljs-comment"># boneh_durfee</span><br><span class="hljs-keyword">if</span> debug:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== running algorithm ===&quot;</span>)<br>    start_time = time.time()<br><br>solx, soly = LSB_boneh_durfee(N, e, d0, M, m, k, tau, X, Y)<br><br><span class="hljs-comment"># found a solution?</span><br><span class="hljs-keyword">if</span> solx &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== solution found ===&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x:&quot;</span>, solx)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;y:&quot;</span>, soly)<br><br>    d = (<span class="hljs-number">1</span> + solx * (N + soly)) // e<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;private key found:&quot;</span>, d)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Check:&quot;</span>, <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,e,N),d,N) == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=== no solution was found ===&quot;</span>)<br><br><span class="hljs-keyword">if</span> debug:<br>    <span class="hljs-built_in">print</span>((<span class="hljs-string">&quot;=== %s seconds ===&quot;</span> % (time.time() - start_time)))<br></code></pre></td></tr></table></figure> 测试结果如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">N = 20332508177191046407161176851715626162427670700170182379012096752462753668314055838790243934946776871851537499388133694556721734570475871908659763281044437965820422742704482916778024833977766679161745563949051389685011338936786669506652703753041024322902154723406511052896275065546091202619464845853706478126658956572904410083939542300795153379083329584933783809925011330795977423308529551383890241176072624856513873214792615204077624895177527276485113723889145486131604377966771362571123712273053003269281344130995499713600168881886640752931118467603319256112412782737344334201037423897547651843769024289745198878627<br>e = 12971607106031794605819918475740223688014101931980680077059601898240049992836560422889290169816486454352812380765802392290380566732461874462438296262583425987695649146094580881844596074916376915352064093677931062246962493521148562297482275246307255774032974146618537922561610165144298380655010351602703366699049509663237688502687028291792631476585770284952992375152013546569003737078697939002333499899729360910936473475389993949647894281151218060545912857559642018154019146647065978025143729492719363599780457295668290198026360422589346941047380860809379417690548864563416252863061490170049074131692907258056721851711<br>M = 137640532496533805613139117345505602754406741092085390510026026754283479635034203912563979741499941<br>d0 = 52394101430824155690531279213649368460443813088150583934469186097651395460571167665118747439471647<br>We want to find: 66485874513349903002569055551920418450043128803161943021567939734289110507223298333426553547744738583191168352607445724663442772307110121369930300914208893828461885478451116632500380669201068574656868319<br>=== checking values ===<br>* delta: 0.330000000000000<br>* delta &lt; 0.368 True<br>* epsilon: 0.170000000000000<br>* epsilon &lt; 0.260865121525004 True<br>* size of e: 2046<br>* size of N: 2047<br>* m: 4<br>=== running algorithm ===<br>20 / 30  vectors are not helpful<br>We do not have det &lt; bound. Solutions might not be found.<br>Try with highers m and t.<br>size det(L) - size (e*M)^(m*n) =  15551<br>00 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>01 0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>02 0 0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>03 X 0 X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>04 0 X 0 X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>05 0 0 0 0 X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>06 0 0 0 0 0 0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>07 0 0 X 0 0 0 X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>08 X 0 X X 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>09 0 X 0 X X 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>10 0 0 0 0 X X 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>11 0 0 0 0 0 X 0 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>12 0 0 0 0 0 0 0 0 0 0 0 0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>13 0 0 0 0 0 0 X 0 0 0 0 0 X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>14 0 0 X 0 0 0 X X 0 0 0 0 X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>15 X 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>16 0 X 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>17 0 0 0 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 0 0 ~<br>18 0 0 0 0 0 X 0 0 0 X X X 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 0 ~<br>19 0 0 0 0 0 0 0 0 0 0 X X 0 0 0 0 X X X X 0 0 0 0 0 0 0 0 0 0 ~<br>20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 X 0 0 0 0 0 0 0 0 0 ~<br>21 0 0 0 0 0 0 0 0 0 0 0 0 X 0 0 0 0 0 0 0 X X 0 0 0 0 0 0 0 0 ~<br>22 0 0 0 0 0 0 X 0 0 0 0 0 X X 0 0 0 0 0 0 X X X 0 0 0 0 0 0 0 ~<br>23 0 0 X 0 0 0 X X 0 0 0 0 X X X 0 0 0 0 0 X X X X 0 0 0 0 0 0 <br>24 X 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 X X X X X 0 0 0 0 0 <br>25 0 X 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 X X X X X 0 0 0 0 <br>26 0 0 0 0 X X 0 0 X X X 0 0 0 X X X X 0 0 0 0 X X X X X 0 0 0 <br>27 0 0 0 0 0 X 0 0 0 X X X 0 0 0 X X X X 0 0 0 0 X X X X X 0 0 ~<br>28 0 0 0 0 0 0 0 0 0 0 X X 0 0 0 0 X X X X 0 0 0 0 X X X X X 0 ~<br>29 0 0 0 0 0 0 0 0 0 0 0 X 0 0 0 0 0 X X X 0 0 0 0 0 X X X X X ~<br>optimizing basis of the lattice via LLL, this can take a long time<br>LLL is done!<br>looking for independent vectors in the lattice<br>found them, using vectors 0 and 1<br>=== solution found ===<br>private key found: 66485874513349903002569055551920418450043128803161943021567939734289110507223298333426553547744738583191168352607445724663442772307110121369930300914208893828461885478451116632500380669201068574656868319<br>Check: True<br>=== 7.360930442810059 seconds ===<br></code></pre></td></tr></table></figure></p><h3 id="已知部分高位msb">已知部分高位（MSB）</h3><p>待补充</p>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
      <category>RSA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
      <tag>Coppersmith</tag>
      
      <tag>Lattice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA 基本概念</title>
    <link href="/Crypto/RSA/5aeae241df92.html"/>
    <url>/Crypto/RSA/5aeae241df92.html</url>
    
    <content type="html"><![CDATA[<p>RSA 是一种非对称加密算法，其安全性基于大整数分解的难度。RSA 算法由Ron Rivest 、Adi Shamir 和 Leonard Adleman在1977年提出，并以其三位发明人的名字命名。</p><h2 id="rsa-算法流程">RSA 算法流程</h2><h4 id="密钥生成">密钥生成</h4><ol type="1"><li>选择两个大质数 $ p $ 和 $ q $，计算它们的乘积 $ n = p q $。</li><li>计算欧拉函数 $ (n) = (p-1)(q-1) $。</li><li>选择一个整数 $ e $，使得 $ 1 &lt; e &lt; (n) $ 且 $ e $ 与 $ (n) $互质。</li><li>计算 $ e $ 在模 $ $ 下的逆元 $ d $，即求出 $ d $ 使得 $ e d $（拓展欧几里得算法）。</li><li>公钥为 $ (e, n) $，私钥为 $ (d, n) $。 #### 加密过程 加密消息 $ m $，要求 $ 0 &lt; m &lt; n $，计算密文 $ c = m^e $。 #### 解密过程解密消息 $ c $ ，计算明文 $ m = c^d <span class="math inline">$。#### 正确性验证$</span> m^{(n)} $ （费马小定理） $ ed ed=1+k(n) $（同余式定义） 由上两式可得 $ c^d= m^{ed}= m^{1+k(n)} =(m<sup>{(n)})</sup>km m $</li></ol><h4 id="代码实现">代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>)<br>e = <span class="hljs-number">65537</span><br>d = <span class="hljs-built_in">pow</span>(e, -<span class="hljs-number">1</span>, phi)<br>m = bytes_to_long(<span class="hljs-string">b&quot;plaintext&quot;</span>)<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Enc:&quot;</span>, long_to_bytes(c))<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dec:&quot;</span>, long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa-的安全性">RSA 的安全性</h2><p>RSA 的安全性基于大整数分解的难度。传统的教科书式 RSA 不能满足 IND-CPA的安全性。在量子计算机中，大整数分解能被 Shor算法在多项式时间内完成。</p>]]></content>
    
    
    <categories>
      
      <category>Crypto</category>
      
      <category>RSA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
